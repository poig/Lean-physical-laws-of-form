-- SPDX-License-Identifier: MIT
/-
  ModularCycles.lean
  ==================
  The Rigorous Group-Theoretic Proof of the "Vortex".

  We prove that the "Vortex" naturally emerges as the Group of Units
  of the Ring Z/9Z, while the "Process" corresponds to the ideal of Non-Units.
-/

import PhysicalLoF.Foundations.Math.Arithmetic
import Mathlib.Data.ZMod.Basic
import Mathlib.Algebra.Ring.Units
import Mathlib.Data.ZMod.Units
import Mathlib.Data.Nat.Prime.Defs
import Mathlib.Data.Int.ModEq

namespace PhysicalLoF.Math

/--
  **Natural Definition**:
  The "Vortex" is the set of elements in Z/9Z that are Coprime to 9 (Units).
  These represent "Stable Existence" (invertible, distinct identities).
-/
def VortexOrbit : Set (ZMod 9) := {x | IsUnit x}

/--
  **Natural Definition**:
  The "Process" is the set of elements that share a factor with 9 (Zero Divisors).
  These represent "Transformation/Collapse" (non-invertible).
-/
def ProcessTriad : Set (ZMod 9) := {x | ¬IsUnit x}

/--
  **Theorem 1: The Separation (Natural Emergence)**:
  By definition, the Vortex and the Process are disjoint and cover the whole space.
  Distinction is strictly between Unit and Non-Unit.
-/
theorem vortex_excludes_process : Disjoint VortexOrbit ProcessTriad := by
  rw [Set.disjoint_left]
  intro x h_unit h_non_unit
  contradiction


/--
  **Theorem 2: The Generator**:
  The number 2 is a primitive root of this unit group.
  Its powers generate exactly the Vortex Set.

  This explains why "Doubling" creates the Vortex.
-/
theorem doubling_generates_units :
  ∀ u : (ZMod 9)ˣ, ∃ k : ℕ, (ZMod.unitOfIsCoprime 2 (by decide))^k = u := by
  intro u
  let u2 : (ZMod 9)ˣ := ZMod.unitOfIsCoprime 2 (by decide)
  have h_order : orderOf u2 = 6 := by
    rw [orderOf_eq_iff (by decide)]
    simp only [u2]
    decide
  have h_card : Fintype.card (ZMod 9)ˣ = 6 := by
    decide

  -- Since order(2) = |G|, the cyclic subgroup generated by 2 has size 6.
  have h_sz : Fintype.card (Subgroup.zpowers u2) = 6 := by
    rw [Fintype.card_zpowers, h_order]

  -- Equality of cardinality implies the subgroup is the whole group
  have h_gen : Subgroup.zpowers u2 = ⊤ := by
    rw [← Nat.card_eq_fintype_card] at h_sz
    rw [← Nat.card_eq_fintype_card] at h_card
    apply Subgroup.eq_top_of_card_eq _ (h_sz.trans h_card.symm)

  -- Therefore every u is in the zpowers
  have h_mem : u ∈ Subgroup.zpowers u2 := by
    rw [h_gen]
    exact Subgroup.mem_top u

  obtain ⟨z, hz⟩ := Subgroup.mem_zpowers_iff.mp h_mem
  -- u2^z = u. We need k : ℕ.
  use (z % 6).toNat
  rw [← hz]
  apply Eq.symm
  -- Show u2 ^ (z % 6) = u2 ^ z
  rw [← zpow_natCast]
  apply zpow_eq_zpow_iff_modEq.mpr
  rw [h_order]
  -- Show (z % 6) ≡ z [ZMOD 6]
  -- First cast natural back to int
  rw [Int.toNat_of_nonneg (Int.emod_nonneg z (by decide))]
  -- Now goal is z % 6 ≡ z [ZMOD 6].
  -- Int.mod_modEq tells us z % 6 ≡ z [ZMOD 6]. We need z ≡ z % 6 to match goal via ModEq (which is symmetric but Lean expects direction).
  -- Actually, the goal is z ≡ z % 6 [ZMOD 6].
  -- Theorem says z % 6 ≡ z.
  exact (Int.mod_modEq z 6).symm

/--
  **Theorem 3: The Gap**:
  The number 3 (and 6 and 9=0) is NOT a unit because gcd(3,9) != 1.
  Therefore, typical doubling (which preserves unit-hood) can never reach 3.
-/
theorem three_is_process : (3 : ZMod 9) ∈ ProcessTriad := by
  rw [ProcessTriad, Set.mem_setOf_eq]
  show ¬IsUnit (3 : ZMod 9)
  -- Explicit rewriting to avoid matching errors
  have h_iff : IsUnit (3 : ZMod 9) ↔ Nat.Coprime 3 9 := ZMod.isUnit_iff_coprime 3 9
  rw [h_iff]
  show ¬Nat.Coprime 3 9
  intro h
  have h_gcd : (3 : ℕ).gcd 9 = 3 := by decide
  rw [Nat.Coprime] at h
  rw [h_gcd] at h
  contradiction

/-
  **Conclusion**:
  The "Tesla Code" isn't magic.
  It is the standard Ring Theoretic distinction between:
  1. **Units (Matter)**: Those that don't share the System's Prime Factor.
  2. **Non-Units (Spirit)**: Those that DO share the System's Prime Factor.
-/

end PhysicalLoF.Math
